const fs = require('fs');
const path = require('path');
const ejs = require('ejs');
const prettier = require('prettier');

/**
 * Utility function to map Prisma types to TypeScript types.
 *
 * @param {string} type - The Prisma field type.
 * @returns {string} The corresponding TypeScript type.
 */
const mapType = (type) => {
  const typeMapping = {
    Int: 'number',
    Float: 'number',
    String: 'string',
    DateTime: 'Date',
    Boolean: 'boolean',
    // Add more mappings as needed
  };
  return typeMapping[type] || 'any';
};

/**
 * Utility function to determine class-validator decorators based on field properties and DTO type.
 *
 * @param {Object} field - The field object containing its properties.
 * @param {string} dtoType - The type of DTO being generated ('Create', 'Update', 'Response').
 * @returns {Array} An array of class-validator decorators.
 */
const getValidators = (field, dtoType) => {
  const validators = [];

  switch (field.type) {
    case 'Int':
      validators.push('IsInt()');
      break;
    case 'Float':
      validators.push('IsNumber()');
      break;
    case 'String':
      validators.push('IsString()');
      break;
    case 'DateTime':
      validators.push('IsDate()');
      break;
    case 'Boolean':
      validators.push('IsBoolean()');
      break;
    default:
      validators.push('IsOptional()');
      break;
  }

  if (dtoType === 'Create' && field.isRequired && !field.isSystemManaged) {
    validators.push('IsNotEmpty()');
  }

  if (dtoType === 'Update') {
    validators.push('IsOptional()');
  }

  return validators;
};

/**
 * Utility function to provide example values based on type.
 *
 * @param {string} type - The Prisma field type.
 * @param {boolean} isRelation - Whether the field is a relation.
 * @param {boolean} isList - Whether the field is a list.
 * @returns {any} An example value corresponding to the type.
 */
const getExampleValue = (type, isRelation = false, isList = false) => {
  if (isRelation) {
    return isList ? '[]' : '{}';
  }
  
  switch (type) {
    case 'Int':
      return 1;
    case 'Float':
      return 1.5;
    case 'String':
      return "'example'";
    case 'DateTime':
      return "'2023-01-01T00:00:00Z'";
    case 'Boolean':
      return true;
    default:
      return "'example'";
  }
};

/**
 * Reads and parses the JSON schema generated by `generateRelationsOutput.js`.
 *
 * @param {string} inputPath - Path to the JSON schema file.
 * @returns {Object} The parsed JSON schema.
 */
const readSchema = (inputPath) => {
  try {
    const schemaRaw = fs.readFileSync(inputPath, 'utf-8');
    return JSON.parse(schemaRaw);
  } catch (error) {
    console.error(`❌ Error reading or parsing schema file at ${inputPath}:`, error.message);
    process.exit(1);
  }
};

/**
 * Ensures that a directory exists. If not, creates it recursively.
 *
 * @param {string} dirPath - The directory path to ensure.
 */
const ensureDirectoryExists = (dirPath) => {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
};

/**
 * Processes each model to generate DTOs based on the JSON schema.
 *
 * @param {Object} schema - The parsed JSON schema.
 * @param {string} outputDir - The base output directory for DTOs.
 * @param {string} templatesDir - The directory containing EJS templates.
 */
const generateDto_all = async (schema, outputDir, templatesDir) => {
  const { allTableFieldsSpec } = schema;

  for (const [entityName, modelSpec] of Object.entries(allTableFieldsSpec)) {
    const entityDir = path.join(outputDir, entityName.toLowerCase(), 'dto');
    ensureDirectoryExists(entityDir);

    // Extract fields
    const fields = Object.values(modelSpec.fields);

    // Determine relationships
    const relations = fields.filter((field) => field.kind === 'object');
    const hasRelations = relations.length > 0;

    // Define DTO types and their corresponding templates
    const dtoTypes = [
      { type: 'Create', template: 'create.dto.ejs' },
      { type: 'Update', template: 'update.dto.ejs' },
      { type: 'Response', template: 'response.dto.ejs' },
    ];

    for (const dto of dtoTypes) {
      let dtoClassName = '';
      let dtoFileName = '';

      switch (dto.type) {
        case 'Create':
          dtoClassName = `Create${entityName}Dto`;
          dtoFileName = `create-${entityName.toLowerCase()}.dto`;
          break;
        case 'Update':
          dtoClassName = `Update${entityName}Dto`;
          dtoFileName = `update-${entityName.toLowerCase()}.dto`;
          break;
        case 'Response':
          dtoClassName = `${entityName}ResponseDto`;
          dtoFileName = `response-${entityName.toLowerCase()}.dto`;
          break;
        default:
          break;
      }

      // Process fields based on DTO type
      let processedFields = [];
      if (dto.type === 'Response') {
        processedFields = fields.map((field) => {
          if (field.kind === 'object') {
            // Relation field: set type to RelatedEntityResponseDto or array thereof
            const relatedEntityName = field.type.replace('Dto', '');
            const relatedEntityResponseDto = `${relatedEntityName}ResponseDto`;
            const tsType = field.isList ? `${relatedEntityResponseDto}[]` : `${relatedEntityResponseDto}`;
            const example = field.isList ? '[]' : '{}';
            return {
              name: field.name,
              type: tsType,
              isOptional: true, // Typically relations are optional
              validators: ['IsOptional()'],
              description: field.name,
              example: example,
              isRelation: true,
              relatedEntity: relatedEntityName,
            };
          } else {
            // Scalar field
            const tsType = mapType(field.type);
            const example = getExampleValue(field.type, false, field.isList);
            return {
              name: field.name,
              type: tsType,
              isOptional: !field.isRequired,
              validators: getValidators(field, dto.type),
              description: field.name,
              example: example,
              isRelation: false,
            };
          }
        });
      } else {
        // Create and Update DTOs
        processedFields = fields
          .filter((field) => {
            // Exclude fields based on DTO type and field properties
            if (dto.type === 'Create' || dto.type === 'Update') {
              // Exclude system-managed fields from Create and Update DTOs
              if (field.isSystemManaged) return false;
              // Exclude relation fields from Create and Update DTOs
              if (field.kind === 'object') return false;
            }
            return true;
          })
          .map((field) => {
            const isOptional = dto.type === 'Update';

            let tsType = mapType(field.type);
            if (field.isList) {
              tsType += '[]';
            }

            const validators = getValidators(field, dto.type);
            const example = getExampleValue(field.type, false, field.isList);

            return {
              name: field.name,
              type: tsType,
              isOptional,
              validators,
              description: field.name,
              example: example,
              isRelation: false,
            };
          });
      }

      // Collect unique validators for import, excluding duplicates
      const importValidatorsSet = new Set();
      processedFields.forEach((field) => {
        field.validators.forEach((validator) => {
          const decoratorName = validator.replace(/\(\)/, '');
          importValidatorsSet.add(decoratorName);
        });
      });
      const importValidators = Array.from(importValidatorsSet).filter(Boolean);

      // Compute import paths for related DTOs (only for Response DTOs)
      let computedRelations = [];
      if (dto.type === 'Response') {
        computedRelations = relations.map((rel) => {
          let relatedEntityName = rel.type;
          // Ensure relatedEntityName ends with 'ResponseDto'
          if (relatedEntityName.endsWith('ResponseDto')) {
            relatedEntityName = relatedEntityName.replace('ResponseDto', '');
          } else {
            // Handle cases where the DTO type does not follow the expected naming convention
            relatedEntityName = relatedEntityName.replace(/Dto$/, '');
          }

          const relatedEntityNameLower =
            relatedEntityName.charAt(0).toLowerCase() + relatedEntityName.slice(1);

          // Construct the relative import path
          const importPath = `../../${relatedEntityName.toLowerCase()}/dto/response-${relatedEntityNameLower.toLowerCase()}.dto`;

          return {
            type: `${relatedEntityName}ResponseDto`,
            importPath: importPath,
          };
        });
      }

      const templateData = {
        entityName,
        dtoClassName,
        fields: processedFields,
        hasRelations,
        relations: computedRelations,
        importValidators,
      };

      const templatePath = path.join(templatesDir, dto.template);
      let template;
      try {
        template = fs.readFileSync(templatePath, 'utf-8');
      } catch (error) {
        console.error(`❌ Error reading template ${dto.template}:`, error.message);
        continue;
      }

      let rendered;
      try {
        rendered = ejs.render(template, templateData);
      } catch (error) {
        console.error(
          `❌ Error rendering template for ${dtoClassName}:`,
          error.message
        );
        continue;
      }

      let formatted;
      try {
        formatted = await prettier.format(rendered, { parser: 'typescript' });
      } catch (error) {
        console.error(`❌ Error formatting code for ${dtoClassName}:`, error.message);
        continue;
      }

      const filePath = path.join(entityDir, `${dtoFileName}.ts`);
      try {
        fs.writeFileSync(filePath, formatted, 'utf-8');
        console.log(`✅ Generated ${filePath}`);
      } catch (error) {
        console.error(`❌ Error writing file ${filePath}:`, error.message);
      }
    }
    console.log('✅ DTOs generated successfully.');
  }
}
/**
 * Main function to orchestrate DTO generation.
 *
 * @param {string} outputDir - The base output directory for DTOs.
 * @param {string} inputPath - Path to the JSON schema file.
 * @param {string} templatesDir - The directory containing EJS templates.
 */
const main = (outputDir, inputPath, templatesDir) => {
  // Read and parse the JSON schema
  const schema = readSchema(inputPath);

  // Generate DTOs based on the schema
  generateDto_all(schema, outputDir, templatesDir);
};

// Extract command-line arguments
const [outputDir, inputPath, templatesDir] = process.argv.slice(2);

// Validate command-line arguments
if (!outputDir || !inputPath || !templatesDir) {
  console.error('❌ Error: Please provide output directory, input JSON path, and templates directory.');
  console.error('Usage: node generatorDTO.js <output-directory> <path-to-schema.json> <templates-directory>');
  process.exit(1);
}

// Execute the main function
main(outputDir, inputPath, templatesDir);
